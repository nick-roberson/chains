{"ast":null,"code":"/* tslint:disable */\n/* eslint-disable */\n/**\n * FastAPI\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nexport const BASE_PATH = \"http://localhost\".replace(/\\/+$/, \"\");\nexport class Configuration {\n  constructor(configuration = {}) {\n    this.configuration = configuration;\n  }\n  set config(configuration) {\n    this.configuration = configuration;\n  }\n  get basePath() {\n    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;\n  }\n  get fetchApi() {\n    return this.configuration.fetchApi;\n  }\n  get middleware() {\n    return this.configuration.middleware || [];\n  }\n  get queryParamsStringify() {\n    return this.configuration.queryParamsStringify || querystring;\n  }\n  get username() {\n    return this.configuration.username;\n  }\n  get password() {\n    return this.configuration.password;\n  }\n  get apiKey() {\n    const apiKey = this.configuration.apiKey;\n    if (apiKey) {\n      return typeof apiKey === \"function\" ? apiKey : () => apiKey;\n    }\n    return undefined;\n  }\n  get accessToken() {\n    const accessToken = this.configuration.accessToken;\n    if (accessToken) {\n      return typeof accessToken === \"function\" ? accessToken : async () => accessToken;\n    }\n    return undefined;\n  }\n  get headers() {\n    return this.configuration.headers;\n  }\n  get credentials() {\n    return this.configuration.credentials;\n  }\n}\nexport const DefaultConfig = new Configuration();\n\n/**\n * This is the base class for all generated API classes.\n */\nexport class BaseAPI {\n  constructor(configuration = DefaultConfig) {\n    this.configuration = configuration;\n    this.middleware = void 0;\n    this.fetchApi = async (url, init) => {\n      let fetchParams = {\n        url,\n        init\n      };\n      for (const middleware of this.middleware) {\n        if (middleware.pre) {\n          fetchParams = (await middleware.pre({\n            fetch: this.fetchApi,\n            ...fetchParams\n          })) || fetchParams;\n        }\n      }\n      let response = undefined;\n      try {\n        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n      } catch (e) {\n        for (const middleware of this.middleware) {\n          if (middleware.onError) {\n            response = (await middleware.onError({\n              fetch: this.fetchApi,\n              url: fetchParams.url,\n              init: fetchParams.init,\n              error: e,\n              response: response ? response.clone() : undefined\n            })) || response;\n          }\n        }\n        if (response === undefined) {\n          if (e instanceof Error) {\n            throw new FetchError(e, \"The request failed and the interceptors did not return an alternative response\");\n          } else {\n            throw e;\n          }\n        }\n      }\n      for (const middleware of this.middleware) {\n        if (middleware.post) {\n          response = (await middleware.post({\n            fetch: this.fetchApi,\n            url: fetchParams.url,\n            init: fetchParams.init,\n            response: response.clone()\n          })) || response;\n        }\n      }\n      return response;\n    };\n    this.middleware = configuration.middleware;\n  }\n  withMiddleware(...middlewares) {\n    const next = this.clone();\n    next.middleware = next.middleware.concat(...middlewares);\n    return next;\n  }\n  withPreMiddleware(...preMiddlewares) {\n    const middlewares = preMiddlewares.map(pre => ({\n      pre\n    }));\n    return this.withMiddleware(...middlewares);\n  }\n  withPostMiddleware(...postMiddlewares) {\n    const middlewares = postMiddlewares.map(post => ({\n      post\n    }));\n    return this.withMiddleware(...middlewares);\n  }\n\n  /**\n   * Check if the given MIME is a JSON MIME.\n   * JSON MIME examples:\n   *   application/json\n   *   application/json; charset=UTF8\n   *   APPLICATION/JSON\n   *   application/vnd.company+json\n   * @param mime - MIME (Multipurpose Internet Mail Extensions)\n   * @return True if the given MIME is JSON, false otherwise.\n   */\n  isJsonMime(mime) {\n    if (!mime) {\n      return false;\n    }\n    return BaseAPI.jsonRegex.test(mime);\n  }\n  async request(context, initOverrides) {\n    const {\n      url,\n      init\n    } = await this.createFetchParams(context, initOverrides);\n    const response = await this.fetchApi(url, init);\n    if (response && response.status >= 200 && response.status < 300) {\n      return response;\n    }\n    throw new ResponseError(response, \"Response returned an error code\");\n  }\n  async createFetchParams(context, initOverrides) {\n    let url = this.configuration.basePath + context.path;\n    if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n      // only add the querystring to the URL if there are query parameters.\n      // this is done to avoid urls ending with a \"?\" character which buggy webservers\n      // do not handle correctly sometimes.\n      url += \"?\" + this.configuration.queryParamsStringify(context.query);\n    }\n    const headers = Object.assign({}, this.configuration.headers, context.headers);\n    Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n    const initOverrideFn = typeof initOverrides === \"function\" ? initOverrides : async () => initOverrides;\n    const initParams = {\n      method: context.method,\n      headers,\n      body: context.body,\n      credentials: this.configuration.credentials\n    };\n    const overriddenInit = {\n      ...initParams,\n      ...(await initOverrideFn({\n        init: initParams,\n        context\n      }))\n    };\n    let body;\n    if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {\n      body = overriddenInit.body;\n    } else if (this.isJsonMime(headers[\"Content-Type\"])) {\n      body = JSON.stringify(overriddenInit.body);\n    } else {\n      body = overriddenInit.body;\n    }\n    const init = {\n      ...overriddenInit,\n      body\n    };\n    return {\n      url,\n      init\n    };\n  }\n  /**\n   * Create a shallow clone of `this` by constructing a new instance\n   * and then shallow cloning data members.\n   */\n  clone() {\n    const constructor = this.constructor;\n    const next = new constructor(this.configuration);\n    next.middleware = this.middleware.slice();\n    return next;\n  }\n}\nBaseAPI.jsonRegex = new RegExp(\"^(:?application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$\", \"i\");\nfunction isBlob(value) {\n  return typeof Blob !== \"undefined\" && value instanceof Blob;\n}\nfunction isFormData(value) {\n  return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nexport class ResponseError extends Error {\n  constructor(response, msg) {\n    super(msg);\n    this.response = response;\n    this.name = \"ResponseError\";\n  }\n}\nexport class FetchError extends Error {\n  constructor(cause, msg) {\n    super(msg);\n    this.cause = cause;\n    this.name = \"FetchError\";\n  }\n}\nexport class RequiredError extends Error {\n  constructor(field, msg) {\n    super(msg);\n    this.field = field;\n    this.name = \"RequiredError\";\n  }\n}\nexport const COLLECTION_FORMATS = {\n  csv: \",\",\n  ssv: \" \",\n  tsv: \"\\t\",\n  pipes: \"|\"\n};\nexport function exists(json, key) {\n  const value = json[key];\n  return value !== null && value !== undefined;\n}\nexport function querystring(params, prefix = \"\") {\n  return Object.keys(params).map(key => querystringSingleKey(key, params[key], prefix)).filter(part => part.length > 0).join(\"&\");\n}\nfunction querystringSingleKey(key, value, keyPrefix = \"\") {\n  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n  if (value instanceof Array) {\n    const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);\n    return `${encodeURIComponent(fullKey)}=${multiValue}`;\n  }\n  if (value instanceof Set) {\n    const valueAsArray = Array.from(value);\n    return querystringSingleKey(key, valueAsArray, keyPrefix);\n  }\n  if (value instanceof Date) {\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n  }\n  if (value instanceof Object) {\n    return querystring(value, fullKey);\n  }\n  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nexport function mapValues(data, fn) {\n  return Object.keys(data).reduce((acc, key) => ({\n    ...acc,\n    [key]: fn(data[key])\n  }), {});\n}\nexport function canConsumeForm(consumes) {\n  for (const consume of consumes) {\n    if (\"multipart/form-data\" === consume.contentType) {\n      return true;\n    }\n  }\n  return false;\n}\nexport class JSONApiResponse {\n  constructor(raw, transformer = jsonValue => jsonValue) {\n    this.raw = raw;\n    this.transformer = transformer;\n  }\n  async value() {\n    return this.transformer(await this.raw.json());\n  }\n}\nexport class VoidApiResponse {\n  constructor(raw) {\n    this.raw = raw;\n  }\n  async value() {\n    return undefined;\n  }\n}\nexport class BlobApiResponse {\n  constructor(raw) {\n    this.raw = raw;\n  }\n  async value() {\n    return await this.raw.blob();\n  }\n}\nexport class TextApiResponse {\n  constructor(raw) {\n    this.raw = raw;\n  }\n  async value() {\n    return await this.raw.text();\n  }\n}","map":{"version":3,"names":["BASE_PATH","replace","Configuration","constructor","configuration","config","basePath","fetchApi","middleware","queryParamsStringify","querystring","username","password","apiKey","undefined","accessToken","headers","credentials","DefaultConfig","BaseAPI","url","init","fetchParams","pre","fetch","response","e","onError","error","clone","Error","FetchError","post","withMiddleware","middlewares","next","concat","withPreMiddleware","preMiddlewares","map","withPostMiddleware","postMiddlewares","isJsonMime","mime","jsonRegex","test","request","context","initOverrides","createFetchParams","status","ResponseError","path","query","Object","keys","length","assign","forEach","key","initOverrideFn","initParams","method","body","overriddenInit","isFormData","URLSearchParams","isBlob","JSON","stringify","slice","RegExp","value","Blob","FormData","msg","name","cause","RequiredError","field","COLLECTION_FORMATS","csv","ssv","tsv","pipes","exists","json","params","prefix","querystringSingleKey","filter","part","join","keyPrefix","fullKey","Array","multiValue","singleValue","encodeURIComponent","String","Set","valueAsArray","from","Date","toISOString","mapValues","data","fn","reduce","acc","canConsumeForm","consumes","consume","contentType","JSONApiResponse","raw","transformer","jsonValue","VoidApiResponse","BlobApiResponse","blob","TextApiResponse","text"],"sources":["/Users/nicholas/Code/chains/my-app/src/api/runtime.ts"],"sourcesContent":["/* tslint:disable */\n/* eslint-disable */\n/**\n * FastAPI\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nexport const BASE_PATH = \"http://localhost\".replace(/\\/+$/, \"\");\n\nexport interface ConfigurationParameters {\n  basePath?: string; // override base path\n  fetchApi?: FetchAPI; // override for fetch implementation\n  middleware?: Middleware[]; // middleware to apply before/after fetch requests\n  queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings\n  username?: string; // parameter for basic security\n  password?: string; // parameter for basic security\n  apiKey?: string | ((name: string) => string); // parameter for apiKey security\n  accessToken?:\n    | string\n    | Promise<string>\n    | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security\n  headers?: HTTPHeaders; //header params we want to use on every request\n  credentials?: RequestCredentials; //value for the credentials param we want to use on each request\n}\n\nexport class Configuration {\n  constructor(private configuration: ConfigurationParameters = {}) {}\n\n  set config(configuration: Configuration) {\n    this.configuration = configuration;\n  }\n\n  get basePath(): string {\n    return this.configuration.basePath != null\n      ? this.configuration.basePath\n      : BASE_PATH;\n  }\n\n  get fetchApi(): FetchAPI | undefined {\n    return this.configuration.fetchApi;\n  }\n\n  get middleware(): Middleware[] {\n    return this.configuration.middleware || [];\n  }\n\n  get queryParamsStringify(): (params: HTTPQuery) => string {\n    return this.configuration.queryParamsStringify || querystring;\n  }\n\n  get username(): string | undefined {\n    return this.configuration.username;\n  }\n\n  get password(): string | undefined {\n    return this.configuration.password;\n  }\n\n  get apiKey(): ((name: string) => string) | undefined {\n    const apiKey = this.configuration.apiKey;\n    if (apiKey) {\n      return typeof apiKey === \"function\" ? apiKey : () => apiKey;\n    }\n    return undefined;\n  }\n\n  get accessToken():\n    | ((name?: string, scopes?: string[]) => string | Promise<string>)\n    | undefined {\n    const accessToken = this.configuration.accessToken;\n    if (accessToken) {\n      return typeof accessToken === \"function\"\n        ? accessToken\n        : async () => accessToken;\n    }\n    return undefined;\n  }\n\n  get headers(): HTTPHeaders | undefined {\n    return this.configuration.headers;\n  }\n\n  get credentials(): RequestCredentials | undefined {\n    return this.configuration.credentials;\n  }\n}\n\nexport const DefaultConfig = new Configuration();\n\n/**\n * This is the base class for all generated API classes.\n */\nexport class BaseAPI {\n  private static readonly jsonRegex = new RegExp(\n    \"^(:?application/json|[^;/ \\t]+/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$\",\n    \"i\",\n  );\n  private middleware: Middleware[];\n\n  constructor(protected configuration = DefaultConfig) {\n    this.middleware = configuration.middleware;\n  }\n\n  withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {\n    const next = this.clone<T>();\n    next.middleware = next.middleware.concat(...middlewares);\n    return next;\n  }\n\n  withPreMiddleware<T extends BaseAPI>(\n    this: T,\n    ...preMiddlewares: Array<Middleware[\"pre\"]>\n  ) {\n    const middlewares = preMiddlewares.map((pre) => ({ pre }));\n    return this.withMiddleware<T>(...middlewares);\n  }\n\n  withPostMiddleware<T extends BaseAPI>(\n    this: T,\n    ...postMiddlewares: Array<Middleware[\"post\"]>\n  ) {\n    const middlewares = postMiddlewares.map((post) => ({ post }));\n    return this.withMiddleware<T>(...middlewares);\n  }\n\n  /**\n   * Check if the given MIME is a JSON MIME.\n   * JSON MIME examples:\n   *   application/json\n   *   application/json; charset=UTF8\n   *   APPLICATION/JSON\n   *   application/vnd.company+json\n   * @param mime - MIME (Multipurpose Internet Mail Extensions)\n   * @return True if the given MIME is JSON, false otherwise.\n   */\n  protected isJsonMime(mime: string | null | undefined): boolean {\n    if (!mime) {\n      return false;\n    }\n    return BaseAPI.jsonRegex.test(mime);\n  }\n\n  protected async request(\n    context: RequestOpts,\n    initOverrides?: RequestInit | InitOverrideFunction,\n  ): Promise<Response> {\n    const { url, init } = await this.createFetchParams(context, initOverrides);\n    const response = await this.fetchApi(url, init);\n    if (response && response.status >= 200 && response.status < 300) {\n      return response;\n    }\n    throw new ResponseError(response, \"Response returned an error code\");\n  }\n\n  private async createFetchParams(\n    context: RequestOpts,\n    initOverrides?: RequestInit | InitOverrideFunction,\n  ) {\n    let url = this.configuration.basePath + context.path;\n    if (\n      context.query !== undefined &&\n      Object.keys(context.query).length !== 0\n    ) {\n      // only add the querystring to the URL if there are query parameters.\n      // this is done to avoid urls ending with a \"?\" character which buggy webservers\n      // do not handle correctly sometimes.\n      url += \"?\" + this.configuration.queryParamsStringify(context.query);\n    }\n\n    const headers = Object.assign(\n      {},\n      this.configuration.headers,\n      context.headers,\n    );\n    Object.keys(headers).forEach((key) =>\n      headers[key] === undefined ? delete headers[key] : {},\n    );\n\n    const initOverrideFn =\n      typeof initOverrides === \"function\"\n        ? initOverrides\n        : async () => initOverrides;\n\n    const initParams = {\n      method: context.method,\n      headers,\n      body: context.body,\n      credentials: this.configuration.credentials,\n    };\n\n    const overriddenInit: RequestInit = {\n      ...initParams,\n      ...(await initOverrideFn({\n        init: initParams,\n        context,\n      })),\n    };\n\n    let body: any;\n    if (\n      isFormData(overriddenInit.body) ||\n      overriddenInit.body instanceof URLSearchParams ||\n      isBlob(overriddenInit.body)\n    ) {\n      body = overriddenInit.body;\n    } else if (this.isJsonMime(headers[\"Content-Type\"])) {\n      body = JSON.stringify(overriddenInit.body);\n    } else {\n      body = overriddenInit.body;\n    }\n\n    const init: RequestInit = {\n      ...overriddenInit,\n      body,\n    };\n\n    return { url, init };\n  }\n\n  private fetchApi = async (url: string, init: RequestInit) => {\n    let fetchParams = { url, init };\n    for (const middleware of this.middleware) {\n      if (middleware.pre) {\n        fetchParams =\n          (await middleware.pre({\n            fetch: this.fetchApi,\n            ...fetchParams,\n          })) || fetchParams;\n      }\n    }\n    let response: Response | undefined = undefined;\n    try {\n      response = await (this.configuration.fetchApi || fetch)(\n        fetchParams.url,\n        fetchParams.init,\n      );\n    } catch (e) {\n      for (const middleware of this.middleware) {\n        if (middleware.onError) {\n          response =\n            (await middleware.onError({\n              fetch: this.fetchApi,\n              url: fetchParams.url,\n              init: fetchParams.init,\n              error: e,\n              response: response ? response.clone() : undefined,\n            })) || response;\n        }\n      }\n      if (response === undefined) {\n        if (e instanceof Error) {\n          throw new FetchError(\n            e,\n            \"The request failed and the interceptors did not return an alternative response\",\n          );\n        } else {\n          throw e;\n        }\n      }\n    }\n    for (const middleware of this.middleware) {\n      if (middleware.post) {\n        response =\n          (await middleware.post({\n            fetch: this.fetchApi,\n            url: fetchParams.url,\n            init: fetchParams.init,\n            response: response.clone(),\n          })) || response;\n      }\n    }\n    return response;\n  };\n\n  /**\n   * Create a shallow clone of `this` by constructing a new instance\n   * and then shallow cloning data members.\n   */\n  private clone<T extends BaseAPI>(this: T): T {\n    const constructor = this.constructor as any;\n    const next = new constructor(this.configuration);\n    next.middleware = this.middleware.slice();\n    return next;\n  }\n}\n\nfunction isBlob(value: any): value is Blob {\n  return typeof Blob !== \"undefined\" && value instanceof Blob;\n}\n\nfunction isFormData(value: any): value is FormData {\n  return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\n\nexport class ResponseError extends Error {\n  override name: \"ResponseError\" = \"ResponseError\";\n  constructor(\n    public response: Response,\n    msg?: string,\n  ) {\n    super(msg);\n  }\n}\n\nexport class FetchError extends Error {\n  override name: \"FetchError\" = \"FetchError\";\n  constructor(\n    public cause: Error,\n    msg?: string,\n  ) {\n    super(msg);\n  }\n}\n\nexport class RequiredError extends Error {\n  override name: \"RequiredError\" = \"RequiredError\";\n  constructor(\n    public field: string,\n    msg?: string,\n  ) {\n    super(msg);\n  }\n}\n\nexport const COLLECTION_FORMATS = {\n  csv: \",\",\n  ssv: \" \",\n  tsv: \"\\t\",\n  pipes: \"|\",\n};\n\nexport type FetchAPI = WindowOrWorkerGlobalScope[\"fetch\"];\n\nexport type Json = any;\nexport type HTTPMethod =\n  | \"GET\"\n  | \"POST\"\n  | \"PUT\"\n  | \"PATCH\"\n  | \"DELETE\"\n  | \"OPTIONS\"\n  | \"HEAD\";\nexport type HTTPHeaders = { [key: string]: string };\nexport type HTTPQuery = {\n  [key: string]:\n    | string\n    | number\n    | null\n    | boolean\n    | Array<string | number | null | boolean>\n    | Set<string | number | null | boolean>\n    | HTTPQuery;\n};\nexport type HTTPBody = Json | FormData | URLSearchParams;\nexport type HTTPRequestInit = {\n  headers?: HTTPHeaders;\n  method: HTTPMethod;\n  credentials?: RequestCredentials;\n  body?: HTTPBody;\n};\nexport type ModelPropertyNaming =\n  | \"camelCase\"\n  | \"snake_case\"\n  | \"PascalCase\"\n  | \"original\";\n\nexport type InitOverrideFunction = (requestContext: {\n  init: HTTPRequestInit;\n  context: RequestOpts;\n}) => Promise<RequestInit>;\n\nexport interface FetchParams {\n  url: string;\n  init: RequestInit;\n}\n\nexport interface RequestOpts {\n  path: string;\n  method: HTTPMethod;\n  headers: HTTPHeaders;\n  query?: HTTPQuery;\n  body?: HTTPBody;\n}\n\nexport function exists(json: any, key: string) {\n  const value = json[key];\n  return value !== null && value !== undefined;\n}\n\nexport function querystring(params: HTTPQuery, prefix: string = \"\"): string {\n  return Object.keys(params)\n    .map((key) => querystringSingleKey(key, params[key], prefix))\n    .filter((part) => part.length > 0)\n    .join(\"&\");\n}\n\nfunction querystringSingleKey(\n  key: string,\n  value:\n    | string\n    | number\n    | null\n    | undefined\n    | boolean\n    | Array<string | number | null | boolean>\n    | Set<string | number | null | boolean>\n    | HTTPQuery,\n  keyPrefix: string = \"\",\n): string {\n  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n  if (value instanceof Array) {\n    const multiValue = value\n      .map((singleValue) => encodeURIComponent(String(singleValue)))\n      .join(`&${encodeURIComponent(fullKey)}=`);\n    return `${encodeURIComponent(fullKey)}=${multiValue}`;\n  }\n  if (value instanceof Set) {\n    const valueAsArray = Array.from(value);\n    return querystringSingleKey(key, valueAsArray, keyPrefix);\n  }\n  if (value instanceof Date) {\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n  }\n  if (value instanceof Object) {\n    return querystring(value as HTTPQuery, fullKey);\n  }\n  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\n\nexport function mapValues(data: any, fn: (item: any) => any) {\n  return Object.keys(data).reduce(\n    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),\n    {},\n  );\n}\n\nexport function canConsumeForm(consumes: Consume[]): boolean {\n  for (const consume of consumes) {\n    if (\"multipart/form-data\" === consume.contentType) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface Consume {\n  contentType: string;\n}\n\nexport interface RequestContext {\n  fetch: FetchAPI;\n  url: string;\n  init: RequestInit;\n}\n\nexport interface ResponseContext {\n  fetch: FetchAPI;\n  url: string;\n  init: RequestInit;\n  response: Response;\n}\n\nexport interface ErrorContext {\n  fetch: FetchAPI;\n  url: string;\n  init: RequestInit;\n  error: unknown;\n  response?: Response;\n}\n\nexport interface Middleware {\n  pre?(context: RequestContext): Promise<FetchParams | void>;\n  post?(context: ResponseContext): Promise<Response | void>;\n  onError?(context: ErrorContext): Promise<Response | void>;\n}\n\nexport interface ApiResponse<T> {\n  raw: Response;\n  value(): Promise<T>;\n}\n\nexport interface ResponseTransformer<T> {\n  (json: any): T;\n}\n\nexport class JSONApiResponse<T> {\n  constructor(\n    public raw: Response,\n    private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue,\n  ) {}\n\n  async value(): Promise<T> {\n    return this.transformer(await this.raw.json());\n  }\n}\n\nexport class VoidApiResponse {\n  constructor(public raw: Response) {}\n\n  async value(): Promise<void> {\n    return undefined;\n  }\n}\n\nexport class BlobApiResponse {\n  constructor(public raw: Response) {}\n\n  async value(): Promise<Blob> {\n    return await this.raw.blob();\n  }\n}\n\nexport class TextApiResponse {\n  constructor(public raw: Response) {}\n\n  async value(): Promise<string> {\n    return await this.raw.text();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}